// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'simple.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#adding-getters-and-methods-to-our-models');

/// @nodoc
mixin _$Test {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() a,
    required TResult Function(int field0) b,
    required TResult Function(String name, int age) c,
    required TResult Function(HiddenType field0) d,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? a,
    TResult? Function(int field0)? b,
    TResult? Function(String name, int age)? c,
    TResult? Function(HiddenType field0)? d,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? a,
    TResult Function(int field0)? b,
    TResult Function(String name, int age)? c,
    TResult Function(HiddenType field0)? d,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Test_A value) a,
    required TResult Function(Test_B value) b,
    required TResult Function(Test_C value) c,
    required TResult Function(Test_D value) d,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(Test_A value)? a,
    TResult? Function(Test_B value)? b,
    TResult? Function(Test_C value)? c,
    TResult? Function(Test_D value)? d,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Test_A value)? a,
    TResult Function(Test_B value)? b,
    TResult Function(Test_C value)? c,
    TResult Function(Test_D value)? d,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $TestCopyWith<$Res> {
  factory $TestCopyWith(Test value, $Res Function(Test) then) =
      _$TestCopyWithImpl<$Res, Test>;
}

/// @nodoc
class _$TestCopyWithImpl<$Res, $Val extends Test>
    implements $TestCopyWith<$Res> {
  _$TestCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$Test_AImplCopyWith<$Res> {
  factory _$$Test_AImplCopyWith(
          _$Test_AImpl value, $Res Function(_$Test_AImpl) then) =
      __$$Test_AImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$Test_AImplCopyWithImpl<$Res>
    extends _$TestCopyWithImpl<$Res, _$Test_AImpl>
    implements _$$Test_AImplCopyWith<$Res> {
  __$$Test_AImplCopyWithImpl(
      _$Test_AImpl _value, $Res Function(_$Test_AImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$Test_AImpl extends Test_A {
  const _$Test_AImpl() : super._();

  @override
  String toString() {
    return 'Test.a()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$Test_AImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() a,
    required TResult Function(int field0) b,
    required TResult Function(String name, int age) c,
    required TResult Function(HiddenType field0) d,
  }) {
    return a();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? a,
    TResult? Function(int field0)? b,
    TResult? Function(String name, int age)? c,
    TResult? Function(HiddenType field0)? d,
  }) {
    return a?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? a,
    TResult Function(int field0)? b,
    TResult Function(String name, int age)? c,
    TResult Function(HiddenType field0)? d,
    required TResult orElse(),
  }) {
    if (a != null) {
      return a();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Test_A value) a,
    required TResult Function(Test_B value) b,
    required TResult Function(Test_C value) c,
    required TResult Function(Test_D value) d,
  }) {
    return a(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(Test_A value)? a,
    TResult? Function(Test_B value)? b,
    TResult? Function(Test_C value)? c,
    TResult? Function(Test_D value)? d,
  }) {
    return a?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Test_A value)? a,
    TResult Function(Test_B value)? b,
    TResult Function(Test_C value)? c,
    TResult Function(Test_D value)? d,
    required TResult orElse(),
  }) {
    if (a != null) {
      return a(this);
    }
    return orElse();
  }
}

abstract class Test_A extends Test {
  const factory Test_A() = _$Test_AImpl;
  const Test_A._() : super._();
}

/// @nodoc
abstract class _$$Test_BImplCopyWith<$Res> {
  factory _$$Test_BImplCopyWith(
          _$Test_BImpl value, $Res Function(_$Test_BImpl) then) =
      __$$Test_BImplCopyWithImpl<$Res>;
  @useResult
  $Res call({int field0});
}

/// @nodoc
class __$$Test_BImplCopyWithImpl<$Res>
    extends _$TestCopyWithImpl<$Res, _$Test_BImpl>
    implements _$$Test_BImplCopyWith<$Res> {
  __$$Test_BImplCopyWithImpl(
      _$Test_BImpl _value, $Res Function(_$Test_BImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? field0 = null,
  }) {
    return _then(_$Test_BImpl(
      null == field0
          ? _value.field0
          : field0 // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }
}

/// @nodoc

class _$Test_BImpl extends Test_B {
  const _$Test_BImpl(this.field0) : super._();

  @override
  final int field0;

  @override
  String toString() {
    return 'Test.b(field0: $field0)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$Test_BImpl &&
            (identical(other.field0, field0) || other.field0 == field0));
  }

  @override
  int get hashCode => Object.hash(runtimeType, field0);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$Test_BImplCopyWith<_$Test_BImpl> get copyWith =>
      __$$Test_BImplCopyWithImpl<_$Test_BImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() a,
    required TResult Function(int field0) b,
    required TResult Function(String name, int age) c,
    required TResult Function(HiddenType field0) d,
  }) {
    return b(field0);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? a,
    TResult? Function(int field0)? b,
    TResult? Function(String name, int age)? c,
    TResult? Function(HiddenType field0)? d,
  }) {
    return b?.call(field0);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? a,
    TResult Function(int field0)? b,
    TResult Function(String name, int age)? c,
    TResult Function(HiddenType field0)? d,
    required TResult orElse(),
  }) {
    if (b != null) {
      return b(field0);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Test_A value) a,
    required TResult Function(Test_B value) b,
    required TResult Function(Test_C value) c,
    required TResult Function(Test_D value) d,
  }) {
    return b(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(Test_A value)? a,
    TResult? Function(Test_B value)? b,
    TResult? Function(Test_C value)? c,
    TResult? Function(Test_D value)? d,
  }) {
    return b?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Test_A value)? a,
    TResult Function(Test_B value)? b,
    TResult Function(Test_C value)? c,
    TResult Function(Test_D value)? d,
    required TResult orElse(),
  }) {
    if (b != null) {
      return b(this);
    }
    return orElse();
  }
}

abstract class Test_B extends Test {
  const factory Test_B(final int field0) = _$Test_BImpl;
  const Test_B._() : super._();

  int get field0;
  @JsonKey(ignore: true)
  _$$Test_BImplCopyWith<_$Test_BImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$Test_CImplCopyWith<$Res> {
  factory _$$Test_CImplCopyWith(
          _$Test_CImpl value, $Res Function(_$Test_CImpl) then) =
      __$$Test_CImplCopyWithImpl<$Res>;
  @useResult
  $Res call({String name, int age});
}

/// @nodoc
class __$$Test_CImplCopyWithImpl<$Res>
    extends _$TestCopyWithImpl<$Res, _$Test_CImpl>
    implements _$$Test_CImplCopyWith<$Res> {
  __$$Test_CImplCopyWithImpl(
      _$Test_CImpl _value, $Res Function(_$Test_CImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? name = null,
    Object? age = null,
  }) {
    return _then(_$Test_CImpl(
      name: null == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String,
      age: null == age
          ? _value.age
          : age // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }
}

/// @nodoc

class _$Test_CImpl extends Test_C {
  const _$Test_CImpl({required this.name, required this.age}) : super._();

  @override
  final String name;
  @override
  final int age;

  @override
  String toString() {
    return 'Test.c(name: $name, age: $age)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$Test_CImpl &&
            (identical(other.name, name) || other.name == name) &&
            (identical(other.age, age) || other.age == age));
  }

  @override
  int get hashCode => Object.hash(runtimeType, name, age);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$Test_CImplCopyWith<_$Test_CImpl> get copyWith =>
      __$$Test_CImplCopyWithImpl<_$Test_CImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() a,
    required TResult Function(int field0) b,
    required TResult Function(String name, int age) c,
    required TResult Function(HiddenType field0) d,
  }) {
    return c(name, age);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? a,
    TResult? Function(int field0)? b,
    TResult? Function(String name, int age)? c,
    TResult? Function(HiddenType field0)? d,
  }) {
    return c?.call(name, age);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? a,
    TResult Function(int field0)? b,
    TResult Function(String name, int age)? c,
    TResult Function(HiddenType field0)? d,
    required TResult orElse(),
  }) {
    if (c != null) {
      return c(name, age);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Test_A value) a,
    required TResult Function(Test_B value) b,
    required TResult Function(Test_C value) c,
    required TResult Function(Test_D value) d,
  }) {
    return c(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(Test_A value)? a,
    TResult? Function(Test_B value)? b,
    TResult? Function(Test_C value)? c,
    TResult? Function(Test_D value)? d,
  }) {
    return c?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Test_A value)? a,
    TResult Function(Test_B value)? b,
    TResult Function(Test_C value)? c,
    TResult Function(Test_D value)? d,
    required TResult orElse(),
  }) {
    if (c != null) {
      return c(this);
    }
    return orElse();
  }
}

abstract class Test_C extends Test {
  const factory Test_C({required final String name, required final int age}) =
      _$Test_CImpl;
  const Test_C._() : super._();

  String get name;
  int get age;
  @JsonKey(ignore: true)
  _$$Test_CImplCopyWith<_$Test_CImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$Test_DImplCopyWith<$Res> {
  factory _$$Test_DImplCopyWith(
          _$Test_DImpl value, $Res Function(_$Test_DImpl) then) =
      __$$Test_DImplCopyWithImpl<$Res>;
  @useResult
  $Res call({HiddenType field0});
}

/// @nodoc
class __$$Test_DImplCopyWithImpl<$Res>
    extends _$TestCopyWithImpl<$Res, _$Test_DImpl>
    implements _$$Test_DImplCopyWith<$Res> {
  __$$Test_DImplCopyWithImpl(
      _$Test_DImpl _value, $Res Function(_$Test_DImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? field0 = null,
  }) {
    return _then(_$Test_DImpl(
      null == field0
          ? _value.field0
          : field0 // ignore: cast_nullable_to_non_nullable
              as HiddenType,
    ));
  }
}

/// @nodoc

class _$Test_DImpl extends Test_D {
  const _$Test_DImpl(this.field0) : super._();

  @override
  final HiddenType field0;

  @override
  String toString() {
    return 'Test.d(field0: $field0)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$Test_DImpl &&
            (identical(other.field0, field0) || other.field0 == field0));
  }

  @override
  int get hashCode => Object.hash(runtimeType, field0);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$Test_DImplCopyWith<_$Test_DImpl> get copyWith =>
      __$$Test_DImplCopyWithImpl<_$Test_DImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() a,
    required TResult Function(int field0) b,
    required TResult Function(String name, int age) c,
    required TResult Function(HiddenType field0) d,
  }) {
    return d(field0);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? a,
    TResult? Function(int field0)? b,
    TResult? Function(String name, int age)? c,
    TResult? Function(HiddenType field0)? d,
  }) {
    return d?.call(field0);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? a,
    TResult Function(int field0)? b,
    TResult Function(String name, int age)? c,
    TResult Function(HiddenType field0)? d,
    required TResult orElse(),
  }) {
    if (d != null) {
      return d(field0);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Test_A value) a,
    required TResult Function(Test_B value) b,
    required TResult Function(Test_C value) c,
    required TResult Function(Test_D value) d,
  }) {
    return d(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(Test_A value)? a,
    TResult? Function(Test_B value)? b,
    TResult? Function(Test_C value)? c,
    TResult? Function(Test_D value)? d,
  }) {
    return d?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Test_A value)? a,
    TResult Function(Test_B value)? b,
    TResult Function(Test_C value)? c,
    TResult Function(Test_D value)? d,
    required TResult orElse(),
  }) {
    if (d != null) {
      return d(this);
    }
    return orElse();
  }
}

abstract class Test_D extends Test {
  const factory Test_D(final HiddenType field0) = _$Test_DImpl;
  const Test_D._() : super._();

  HiddenType get field0;
  @JsonKey(ignore: true)
  _$$Test_DImplCopyWith<_$Test_DImpl> get copyWith =>
      throw _privateConstructorUsedError;
}
